---
authors: Markus Rudy (@burgerdev)
state: committed
---

# Objective

Make the GLOME Login Protocol unambiguous.


# Background

See also [google/glome#62](https://github.com/google/glome/issues/62).

*   The ambiguous interpretation of `prefix7` may lead to a change of server authorization behaviour that cannot be controlled by the client (e.g. a new key is added to the server whose index conflicts with a public key prefix of an existing one).
*   It's currently legal to have colon (`:`) and slash (`/`) characters in all message fields, which may cause ambiguity in parsing and, ultimately, lead to authorization of unintended messages.
*   The protocol gives advice to "maximize the human readability of the URL", which conflicts with an unambiguous presentation of said characters in percent-encoded form.


# Requirements

*   There must be a well-defined interpretation of the GLOME Login handshake that does not depend on the state of the server.
*   There must be a well-defined, bijective conversion from the message embedded in a GLOME Login URL to the message being authorized.
*   Subject to the preceding requirements, the URL layout should be optimized for human readability (e.g. don't encode unreserved characters, go/rfc/3986#section-2.3) and brevity.
    -   Assuming humans will have to read the message to be authorized much more often than parse the involved keys.


# Design ideas

*   Remove the `prefix7` interpretation as a public key prefix.
*   Completely specify the encoding and decoding of the message part.
*   Include detailed instructions for server and client into the protocol.
*   Publish the result as GLOME Login v2.


## Prefix7

Remove this wording from the protocol specification:

> or if no index found will be matched<br>with the public key (to be administrator configurable)

Only support service key index throughout the codebase.

## Message

Define a normalized encoding of the authorization context and compute the tag over that encoding.

New restrictions:

*   `hostid-type` and `hostid` must not contain the `:` character.
*   `hostid-type`, `hostid` and `action` should not contain any characters that would be escaped in a URI path segment (as detailed below). Differing from previous protocol versions, `/` is discouraged.


### URI Path Segments

The URI specification [RFC 3986](https://www.ietf.org/rfc/rfc3986.html#section-3.3) defines a path segment as

```abns
segment = *pchar
pchar = unreserved / pct-encoded / sub-delims / ":" / "@"
unreserved  = ALPHA / DIGIT / "-" / "." / "_" / "~"
sub-delims  = "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
pct-encoded = "%" HEXDIG HEXDIG
```

where HEXDIG should refer to a digit or an uppercase letter A-F. This matches the definition in https://url.spec.whatwg.org/#url-path-segment-string, which supposedly supersedes the RFC.

Thus, define `EscapePathSegment` as a function that escapes all characters that are not unreserved, sub delimiters, `:` or `@`. See the Appendix for how this function can be implemented in some of the major programming languages.


### Message Encoding

Constructing a message takes three parameters: `hostid`, `action` and (optionally) `hostid-type`. The content to be embedded in the URL consists of 2 path segments: `host-segment` and `action-segment`.

```abns
host-segment = EscapePathSegment( [hostid-type ':'] hostid )
action-segment = EscapePathSegment(action)
message = host-segment '/' action-segment
```

The `hostid-type` prefix is added if and only if the `hostid-type` of the message is not empty.

Note that this voids some of the existing recommendations for 'good' actions: `shell/root`, for example, would have to be escaped and thus be less readable. Instead, using URI sub-delimiters as in `shell=root` should be recommended. This format would interact nicely with a host-identity-based authorization scheme working with key-value pairs.


### Message Decoding

Take the URL prefix up to including the `/` after the handshake message. Split this string on the character `/` and keep only the first and second element, denoted `host-segment` and `action-segment`; or fail if there are less than two elements. Replace all percent-encoded octets in the `host-segment` with their raw, unencoded form. Split the result at the character `:`. If there is one element, assign that element to `hostid` and assign the literal string `hostname` to `hostid-type`; if there are two elements assign the first one to `hostid-type` and the second to `hostid`; if there are more than two elements, fail. Replace all percent-encoded octets in the `action-segment` with their raw, unencoded form, and assign the result to `action`.


### Message Tagging

The tag for a message is produced by passing the **encoded message** string into `glome_tag`.

# Alternatives considered

## URL Format

* Allow an action to span more than one path segment.
    *   This prevents us from having an unambiguous encoding: `xxx/yyy%2Fzzz` vs. `xxx/yyy/zzz`.

## Message

*   Tag the message before URL escaping.
    *   This would have the benefit of decoupling the tagging from the transport (here, URL segments).
    *   However, we need to encode the message into a byte array before we can tag it. This encoding must be unambiguous as well, simply concatenating the triple won't cut it.


# Appendix

## URL Path Escaping APIs

### Python

```python
urllib.parse.quote(segment, safe=":@!$&'()*+,;=")
```


### Golang

:'-( https://github.com/golang/go/issues/27559


### C

GLib:

```c
g_uri_escape_string(segment, ":@!$&'()*+,;=", /*allow_utf8=*/false);
```


### Java

Guava:

```java
com.google.common.net.UrlEscapers.urlPathSegmentEscaper().escape(segment)
```


### OCaml

Uri:

```ocaml
Uri.pct_encode segment
```
